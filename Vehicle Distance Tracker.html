<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mobile Camera Stream</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .control-button {
            @apply bg-gray-800 text-white p-3 rounded-lg shadow-lg active:bg-gray-700;
        }
        .status-indicator {
            @apply inline-block w-3 h-3 rounded-full mr-2;
        }
        .fullscreen-video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            z-index: 9999;
        }
        .zoom-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen">
    <!-- Header -->
    <div class="bg-gray-800 p-4 flex justify-between items-center">
        <h1 class="text-xl font-bold">üìπ Mobile Stream</h1>
        <div class="flex items-center space-x-2">
            <span id="connection-status" class="status-indicator bg-red-500"></span>
            <span id="battery-status" class="text-sm">üîã</span>
            <button id="settings-btn" class="control-button">‚öôÔ∏è</button>
        </div>
    </div>

    <!-- Main Video Container -->
    <div class="relative bg-black aspect-video mx-4 my-4 rounded-lg overflow-hidden">
        <video id="camera-preview" class="w-full h-full object-cover" autoplay muted playsinline></video>
        
        <!-- Video Overlay Controls -->
        <div class="absolute inset-0 flex items-center justify-center opacity-0 hover:opacity-100 transition-opacity" id="video-overlay">
            <button id="fullscreen-btn" class="bg-black bg-opacity-50 text-white p-3 rounded-full">
                <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
                </svg>
            </button>
        </div>

        <!-- Stream URL Display -->
        <div id="stream-url-display" class="absolute bottom-2 left-2 right-2 bg-black bg-opacity-70 p-2 rounded text-xs hidden">
            <div class="text-green-400 font-mono" id="stream-url">Stream: Connecting...</div>
        </div>
    </div>

    <!-- Camera Controls -->
    <div class="mx-4 space-y-4">
        <!-- Primary Controls -->
        <div class="grid grid-cols-3 gap-3">
            <button id="camera-switch" class="control-button flex flex-col items-center">
                <span class="text-2xl">üîÑ</span>
                <span class="text-xs mt-1">Switch</span>
            </button>
            <button id="start-stream" class="bg-red-600 text-white p-3 rounded-lg shadow-lg active:bg-red-700 flex flex-col items-center">
                <span class="text-2xl">üì°</span>
                <span class="text-xs mt-1">Stream</span>
            </button>
            <button id="flash-toggle" class="control-button flex flex-col items-center">
                <span class="text-2xl">üí°</span>
                <span class="text-xs mt-1">Flash</span>
            </button>
        </div>

        <!-- Zoom Control -->
        <div class="bg-gray-800 p-4 rounded-lg">
            <label class="block text-sm font-medium mb-2">Zoom: <span id="zoom-value">1x</span></label>
            <input type="range" id="zoom-slider" class="zoom-slider w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer" 
                   min="1" max="10" step="0.1" value="1">
        </div>

        <!-- Resolution & Quality -->
        <div class="grid grid-cols-2 gap-3">
            <div class="bg-gray-800 p-3 rounded-lg">
                <label class="block text-sm font-medium mb-2">Resolution</label>
                <select id="resolution-select" class="w-full bg-gray-700 text-white p-2 rounded">
                    <option value="480">480p</option>
                    <option value="720" selected>720p</option>
                    <option value="1080">1080p</option>
                </select>
            </div>
            <div class="bg-gray-800 p-3 rounded-lg">
                <label class="block text-sm font-medium mb-2">Focus Mode</label>
                <select id="focus-select" class="w-full bg-gray-700 text-white p-2 rounded">
                    <option value="continuous">Auto</option>
                    <option value="single-shot">Single</option>
                    <option value="manual">Manual</option>
                </select>
            </div>
        </div>

        <!-- Stream Info -->
        <div class="bg-gray-800 p-4 rounded-lg space-y-2">
            <div class="flex justify-between">
                <span class="text-sm">Stream Status:</span>
                <span id="stream-status" class="text-sm text-red-400">Stopped</span>
            </div>
            <div class="flex justify-between">
                <span class="text-sm">Local IP:</span>
                <span id="local-ip" class="text-sm text-blue-400">Detecting...</span>
            </div>
            <div class="flex justify-between">
                <span class="text-sm">Viewers:</span>
                <span id="viewer-count" class="text-sm text-green-400">0</span>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50">
        <div class="bg-gray-800 m-4 p-6 rounded-lg w-full max-w-md">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg font-bold">Settings</h2>
                <button id="close-settings" class="text-gray-400 hover:text-white">‚úï</button>
            </div>
            
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium mb-2">Stream Port</label>
                    <input type="number" id="stream-port" value="8080" class="w-full bg-gray-700 text-white p-2 rounded">
                </div>
                
                <div>
                    <label class="block text-sm font-medium mb-2">Stream Quality</label>
                    <select id="quality-select" class="w-full bg-gray-700 text-white p-2 rounded">
                        <option value="high">High Quality</option>
                        <option value="medium" selected>Medium Quality</option>
                        <option value="low">Low Quality</option>
                    </select>
                </div>
                
                <div class="flex items-center justify-between">
                    <span class="text-sm">Show Stream URL</span>
                    <input type="checkbox" id="show-url-toggle" class="w-4 h-4">
                </div>
                
                <div class="flex items-center justify-between">
                    <span class="text-sm">Auto-start Stream</span>
                    <input type="checkbox" id="auto-start-toggle" class="w-4 h-4">
                </div>
            </div>
            
            <button id="save-settings" class="w-full bg-blue-600 text-white p-3 rounded-lg mt-4 hover:bg-blue-700">
                Save Settings
            </button>
        </div>
    </div>

    <!-- Instructions Panel -->
    <div class="mx-4 mt-6 mb-8">
        <div class="bg-blue-900 bg-opacity-50 p-4 rounded-lg">
            <h3 class="font-bold mb-2">üìã OBS Setup Instructions</h3>
            <ol class="text-sm space-y-1 list-decimal list-inside">
                <li>Start streaming on your mobile device</li>
                <li>Note the stream URL displayed above</li>
                <li>In OBS, add "Browser Source" or "Media Source"</li>
                <li>Enter the stream URL: http://[YOUR-IP]:8080/stream</li>
                <li>Set width: 1920, height: 1080 (or your resolution)</li>
            </ol>
        </div>
    </div>

    <script>
        class MobileCameraStream {
            constructor() {
                this.video = document.getElementById('camera-preview');
                this.stream = null;
                this.mediaRecorder = null;
                this.isStreaming = false;
                this.currentCamera = 'user'; // 'user' or 'environment'
                this.currentZoom = 1;
                this.streamPort = 8080;
                this.peerConnections = new Map();
                this.localIP = null;
                this.capabilities = null;
                
                this.initializeApp();
            }

            async initializeApp() {
                await this.detectLocalIP();
                this.setupEventListeners();
                this.setupOrientationHandler();
                this.requestCameraPermission();
                this.updateBatteryStatus();
                this.setupWebRTCSignaling();
            }

            async detectLocalIP() {
                try {
                    // Create a dummy peer connection to get local IP
                    const pc = new RTCPeerConnection({
                        iceServers: [{urls: "stun:stun.l.google.com:19302"}]
                    });
                    
                    pc.createDataChannel("");
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    
                    const localIP = await new Promise((resolve) => {
                        pc.onicecandidate = (event) => {
                            if (event.candidate) {
                                const candidate = event.candidate.candidate;
                                const ipMatch = candidate.match(/(\d+\.\d+\.\d+\.\d+)/);
                                if (ipMatch) {
                                    resolve(ipMatch[1]);
                                }
                            }
                        };
                    });
                    
                    this.localIP = localIP;
                    document.getElementById('local-ip').textContent = localIP || 'Unknown';
                    pc.close();
                } catch (error) {
                    console.error('Failed to detect local IP:', error);
                    document.getElementById('local-ip').textContent = 'Detection failed';
                }
            }

            setupWebRTCSignaling() {
                // Simulate a simple signaling server using WebSocket (would need actual server)
                // For this demo, we'll use direct peer connection setup
                this.createStreamingEndpoint();
            }

            createStreamingEndpoint() {
                // Create a simple HTTP server simulation for OBS compatibility
                // In reality, this would need a proper WebRTC signaling server
                const streamUrl = `http://${this.localIP}:${this.streamPort}/stream`;
                document.getElementById('stream-url').textContent = `Stream: ${streamUrl}`;
            }

            setupEventListeners() {
                // Camera controls
                document.getElementById('camera-switch').addEventListener('click', () => this.switchCamera());
                document.getElementById('start-stream').addEventListener('click', () => this.toggleStream());
                document.getElementById('flash-toggle').addEventListener('click', () => this.toggleFlash());
                document.getElementById('fullscreen-btn').addEventListener('click', () => this.toggleFullscreen());
                
                // Settings
                document.getElementById('settings-btn').addEventListener('click', () => this.showSettings());
                document.getElementById('close-settings').addEventListener('click', () => this.hideSettings());
                document.getElementById('save-settings').addEventListener('click', () => this.saveSettings());
                
                // Controls
                document.getElementById('zoom-slider').addEventListener('input', (e) => this.setZoom(e.target.value));
                document.getElementById('resolution-select').addEventListener('change', (e) => this.changeResolution(e.target.value));
                document.getElementById('focus-select').addEventListener('change', (e) => this.changeFocusMode(e.target.value));
                
                // Show URL toggle
                document.getElementById('show-url-toggle').addEventListener('change', (e) => {
                    const display = document.getElementById('stream-url-display');
                    display.classList.toggle('hidden', !e.target.checked);
                });
            }

            setupOrientationHandler() {
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => {
                        if (this.stream) {
                            this.applyCurrentSettings();
                        }
                    }, 500);
                });
            }

            async requestCameraPermission() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { facingMode: this.currentCamera },
                        audio: true 
                    });
                    this.setStream(stream);
                    this.updateConnectionStatus('connected');
                } catch (error) {
                    console.error('Camera permission denied:', error);
                    this.showError('Camera access denied. Please enable camera permissions.');
                    this.updateConnectionStatus('error');
                }
            }

            async switchCamera() {
                if (!this.stream) return;
                
                this.currentCamera = this.currentCamera === 'user' ? 'environment' : 'user';
                
                try {
                    this.stream.getTracks().forEach(track => track.stop());
                    
                    const constraints = {
                        video: {
                            facingMode: this.currentCamera,
                            width: { ideal: this.getCurrentResolution().width },
                            height: { ideal: this.getCurrentResolution().height }
                        },
                        audio: true
                    };
                    
                    const newStream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.setStream(newStream);
                    this.applyCurrentSettings();
                } catch (error) {
                    console.error('Failed to switch camera:', error);
                    this.showError('Failed to switch camera');
                }
            }

            setStream(stream) {
                this.stream = stream;
                this.video.srcObject = stream;
                
                // Get camera capabilities
                const videoTrack = stream.getVideoTracks()[0];
                if (videoTrack) {
                    this.capabilities = videoTrack.getCapabilities();
                    this.setupZoomLimits();
                }
            }

            setupZoomLimits() {
                if (this.capabilities && this.capabilities.zoom) {
                    const zoomSlider = document.getElementById('zoom-slider');
                    zoomSlider.min = this.capabilities.zoom.min;
                    zoomSlider.max = this.capabilities.zoom.max;
                    zoomSlider.step = this.capabilities.zoom.step || 0.1;
                }
            }

            async setZoom(zoomLevel) {
                this.currentZoom = zoomLevel;
                document.getElementById('zoom-value').textContent = `${zoomLevel}x`;
                
                if (this.stream && this.capabilities && this.capabilities.zoom) {
                    const videoTrack = this.stream.getVideoTracks()[0];
                    try {
                        await videoTrack.applyConstraints({
                            advanced: [{ zoom: zoomLevel }]
                        });
                    } catch (error) {
                        console.error('Zoom not supported:', error);
                    }
                }
            }

            async toggleFlash() {
                if (!this.stream) return;
                
                const videoTrack = this.stream.getVideoTracks()[0];
                const capabilities = videoTrack.getCapabilities();
                
                if (capabilities.torch) {
                    const settings = videoTrack.getSettings();
                    try {
                        await videoTrack.applyConstraints({
                            advanced: [{ torch: !settings.torch }]
                        });
                        
                        const flashBtn = document.getElementById('flash-toggle');
                        flashBtn.classList.toggle('bg-yellow-600', !settings.torch);
                    } catch (error) {
                        console.error('Flash control failed:', error);
                    }
                } else {
                    this.showError('Flash not supported on this device');
                }
            }

            getCurrentResolution() {
                const resolution = document.getElementById('resolution-select').value;
                const resolutions = {
                    '480': { width: 854, height: 480 },
                    '720': { width: 1280, height: 720 },
                    '1080': { width: 1920, height: 1080 }
                };
                return resolutions[resolution];
            }

            async changeResolution(resolution) {
                if (!this.stream) return;
                
                const res = this.getCurrentResolution();
                const videoTrack = this.stream.getVideoTracks()[0];
                
                try {
                    await videoTrack.applyConstraints({
                        width: { ideal: res.width },
                        height: { ideal: res.height }
                    });
                } catch (error) {
                    console.error('Resolution change failed:', error);
                    this.showError('Failed to change resolution');
                }
            }

            async changeFocusMode(focusMode) {
                if (!this.stream) return;
                
                const videoTrack = this.stream.getVideoTracks()[0];
                const capabilities = videoTrack.getCapabilities();
                
                if (capabilities.focusMode && capabilities.focusMode.includes(focusMode)) {
                    try {
                        await videoTrack.applyConstraints({
                            advanced: [{ focusMode: focusMode }]
                        });
                    } catch (error) {
                        console.error('Focus mode change failed:', error);
                    }
                }
            }

            async toggleStream() {
                const btn = document.getElementById('start-stream');
                const status = document.getElementById('stream-status');
                
                if (!this.isStreaming) {
                    try {
                        await this.startStreaming();
                        btn.innerHTML = '<span class="text-2xl">‚èπÔ∏è</span><span class="text-xs mt-1">Stop</span>';
                        btn.classList.replace('bg-red-600', 'bg-gray-600');
                        status.textContent = 'Streaming';
                        status.classList.replace('text-red-400', 'text-green-400');
                        this.updateConnectionStatus('streaming');
                    } catch (error) {
                        console.error('Failed to start streaming:', error);
                        this.showError('Failed to start streaming');
                    }
                } else {
                    this.stopStreaming();
                    btn.innerHTML = '<span class="text-2xl">üì°</span><span class="text-xs mt-1">Stream</span>';
                    btn.classList.replace('bg-gray-600', 'bg-red-600');
                    status.textContent = 'Stopped';
                    status.classList.replace('text-green-400', 'text-red-400');
                    this.updateConnectionStatus('connected');
                }
            }

            async startStreaming() {
                if (!this.stream) {
                    throw new Error('No camera stream available');
                }

                // Create MediaRecorder for streaming
                const options = { mimeType: 'video/webm;codecs=vp8,opus' };
                this.mediaRecorder = new MediaRecorder(this.stream, options);
                
                const chunks = [];
                this.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        chunks.push(event.data);
                        this.broadcastToViewers(event.data);
                    }
                };

                this.mediaRecorder.start(100); // Record in 100ms chunks
                this.isStreaming = true;
                
                // Simulate viewer connection for demo
                setTimeout(() => {
                    document.getElementById('viewer-count').textContent = '1';
                }, 2000);
            }

            stopStreaming() {
                if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                    this.mediaRecorder.stop();
                }
                this.isStreaming = false;
                document.getElementById('viewer-count').textContent = '0';
                
                // Close all peer connections
                this.peerConnections.forEach(pc => pc.close());
                this.peerConnections.clear();
            }

            broadcastToViewers(chunk) {
                // In a real implementation, this would send data to connected viewers
                // For demo purposes, we'll just log the streaming activity
                console.log('Broadcasting chunk of size:', chunk.size);
            }

            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    this.video.requestFullscreen().then(() => {
                        this.video.classList.add('fullscreen-video');
                    });
                } else {
                    document.exitFullscreen().then(() => {
                        this.video.classList.remove('fullscreen-video');
                    });
                }
            }

            showSettings() {
                document.getElementById('settings-modal').classList.remove('hidden');
            }

            hideSettings() {
                document.getElementById('settings-modal').classList.add('hidden');
            }

            saveSettings() {
                const port = document.getElementById('stream-port').value;
                const quality = document.getElementById('quality-select').value;
                const autoStart = document.getElementById('auto-start-toggle').checked;
                
                this.streamPort = parseInt(port);
                this.createStreamingEndpoint();
                
                // Apply quality settings
                this.applyQualitySettings(quality);
                
                this.hideSettings();
            }

            applyQualitySettings(quality) {
                if (!this.stream) return;
                
                const videoTrack = this.stream.getVideoTracks()[0];
                const qualitySettings = {
                    high: { width: 1920, height: 1080, frameRate: 30 },
                    medium: { width: 1280, height: 720, frameRate: 30 },
                    low: { width: 854, height: 480, frameRate: 24 }
                };
                
                const settings = qualitySettings[quality];
                videoTrack.applyConstraints({
                    width: { ideal: settings.width },
                    height: { ideal: settings.height },
                    frameRate: { ideal: settings.frameRate }
                }).catch(error => console.error('Quality adjustment failed:', error));
            }

            applyCurrentSettings() {
                this.setZoom(this.currentZoom);
                const resolution = document.getElementById('resolution-select').value;
                this.changeResolution(resolution);
            }

            updateConnectionStatus(status) {
                const indicator = document.getElementById('connection-status');
                indicator.className = 'status-indicator ';
                
                switch (status) {
                    case 'connected':
                        indicator.classList.add('bg-green-500');
                        break;
                    case 'streaming':
                        indicator.classList.add('bg-blue-500');
                        break;
                    case 'error':
                        indicator.classList.add('bg-red-500');
                        break;
                    default:
                        indicator.classList.add('bg-yellow-500');
                }
            }

            updateBatteryStatus() {
                if ('getBattery' in navigator) {
                    navigator.getBattery().then(battery => {
                        const updateBattery = () => {
                            const level = Math.round(battery.level * 100);
                            const charging = battery.charging ? '‚ö°' : '';
                            document.getElementById('battery-status').textContent = `üîã${level}%${charging}`;
                        };
                        
                        updateBattery();
                        battery.addEventListener('levelchange', updateBattery);
                        battery.addEventListener('chargingchange', updateBattery);
                    });
                }
            }

            showError(message) {
                // Create a simple toast notification
                const toast = document.createElement('div');
                toast.className = 'fixed top-4 left-4 right-4 bg-red-600 text-white p-3 rounded-lg z-50';
                toast.textContent = message;
                document.body.appendChild(toast);
                
                setTimeout(() => {
                    document.body.removeChild(toast);
                }, 3000);
            }
        }

        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new MobileCameraStream();
        });

        // Handle page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Optionally pause streaming when app goes to background
                console.log('App went to background');
            } else {
                console.log('App came to foreground');
            }
        });
    </script>
</body>
</html>
